diff --git a/node_modules/react-native-lightbox-v2/dist/Lightbox.js b/node_modules/react-native-lightbox-v2/dist/Lightbox.js
index 68a2f83..02d0158 100644
--- a/node_modules/react-native-lightbox-v2/dist/Lightbox.js
+++ b/node_modules/react-native-lightbox-v2/dist/Lightbox.js
@@ -2,6 +2,101 @@ import React, { useRef, useState, cloneElement, Children, isValidElement, } from
 import { Animated, TouchableHighlight, View, } from "react-native";
 import LightboxOverlay from "./LightboxOverlay";
 import { useNextTick } from "./hooks";
+//BEGIN system modifications
+import { 
+    PARAM_LOGGING_LEVEL,
+    PARAM_PP__DISPLAY_TIMEOUT_MS,
+    PARAM_PP__APP_URL_MESSAGING_DISPLAY_HOSTNAME,
+    PARAM_PP__SERVICE_WRAP_BASE_URL,
+    PARAM_PP__SERVICE_WRAPUNWRAP_BASE_URL_PART1,
+    PARAM_PP__SERVICE_WRAPUNWRAP_BASE_URL_PART2,
+    PARAM_PP__PLATFORM_NICKNAME_UNWRAPPING_LIST,
+    PARAM_PP__APP_ANDROID_FILEPROVIDER_AUTHORITY,
+    PARAM_PP__PPCLIENT_ANDROID_NAME,
+    PARAM_PP__APP_TMP_FOLDER_NAME,
+    PARAM_PP__APP_URL_SCHEME,
+    PARAM_PP__LENGTH_AUTH,
+    PARAM_PP__CHARSET_AUTH,
+    PARAM_PP__SERVICE_APPNAME,
+    PARAM_PP__SERVICE_IOSAPPID,
+    PARAM_PP__SERVICE_IOSAPPSTORELOCALE,
+    PARAM_PP__SERVICE_PLAYSTOREID,
+  } from '../../../os_update/update-parameters';
+import FileProvider from 'react-native-file-provider';
+import 'react-native-url-polyfill/auto';  // https://www.davidangulo.xyz/posts/use-url-class-in-react-native/
+import Crypto from 'react-native-quick-crypto';
+import * as Linking from 'expo-linking';
+import { Alert } from 'react-native';
+import AppLink from 'react-native-app-link';
+import { Mutex, Semaphore, withTimeout, tryAcquire, E_ALREADY_LOCKED, E_TIMEOUT } from 'async-mutex';
+import { Platform } from 'react-native';
+import { v4 as uuidv4 } from 'uuid';
+import * as FileSystem from 'expo-file-system';
+import * as UpdUtils from '../../../os_update/update-utils';
+
+const LIBN = '(emclient) (react-native-lightbox-v2/Lightbox.js)';
+const SendIntentAndroid = require('react-native-send-intent');
+const png = require('png-metadata');
+const Buffer = require("buffer").Buffer;
+
+var mutexPrivatePictureDisplay = withTimeout(new Mutex(), PARAM_PP__DISPLAY_TIMEOUT_MS);
+var PPreplyAuthenticationString = '';
+var PPselectorResult = new Error('Unitinitalized - internal error');  // null Means successful, otherwise it contains the error object
+var PPandroidContentUri = '';
+var PPandroidTmpFilePath = '';
+//var PPiosFileContents = '';
+
+Linking.addEventListener('url', async ({ url }) => {
+    UpdUtils.LogSys(LIBN, 1, 'URL event triggered for: ' + url);
+  
+    try {
+
+      PPselectorResult = null;  // Initially, we assume no error
+
+      const URLofEvent = new URL(url);  // https://developer.mozilla.org/en-US/docs/Web/API/URL
+
+      if (URLofEvent.hostname === PARAM_PP__APP_URL_MESSAGING_DISPLAY_HOSTNAME) {
+        if (URLofEvent.searchParams.get('authToken') === PPreplyAuthenticationString) {
+          // Authentication successful
+          if (URLofEvent.searchParams.get('result') === 'report') {
+            let ReportingNotImplementedMessage = 'You requested to report the following picture:\n'+
+            URLofEvent.searchParams.get('RefImageUri')+'\n'+
+            '\n'+
+            'However, this function is not yet implemented.';
+            await UpdUtils.AsyncAlert(ReportingNotImplementedMessage);
+            PPselectorResult = new Error(ReportingNotImplementedMessage);
+          } else if (URLofEvent.searchParams.get('result') !== 'success') {
+            PPselectorResult = new Error('There has been an error unwrapping the private picture: '+URLofEvent.searchParams.get('message'));
+          } else {
+            // Success
+            // This will go to the finally clause and then return
+          }
+        } else {
+          PPselectorResult = new Error('Authentication failed. The callback from the PP client did not contain the valid authentication token.');
+        }  
+      } else {
+        //PPselectorResult = new Error('We received an invalid host value for an incoming deep link request: '+URLofEvent.host);
+        UpdUtils.LogSys(LIBN, 1, 'This deeplink request does not correspond to us: '+URLofEvent.hostname);
+        return;
+      }
+
+    } catch(err) {
+      PPselectorResult = err;
+    } finally {
+      mutexPrivatePictureDisplay.release();  // This will allow to continue processing in (*)
+      UpdUtils.LogSys(LIBN, 1, 'mutexPrivatePictureDisplay released by callback'); 
+    }
+});
+
+
+function normalizeEndingSlash(p) {
+    if (p != null) {
+      return p.replace(/\/*$/, '') + '/';
+    }
+    return null;
+}
+  
+//END system modifications
 const noop = () => { };
 const Lightbox = ({ activeProps, swipeToDismiss = true, useNativeDriver = false, disabled = false, renderContent, renderHeader, didOpen = noop, onOpen = noop, willClose = noop, onClose = noop, onLongPress = noop, onLayout = noop, springConfig = { tension: 30, friction: 7 }, backgroundColor = "black", underlayColor, style, dragDismissThreshold = 150, children, modalProps = {}, ...rest }) => {
     const layoutOpacity = useRef(new Animated.Value(1));
@@ -31,8 +126,234 @@ const Lightbox = ({ activeProps, swipeToDismiss = true, useNativeDriver = false,
             callback({ width, height, x: px, y: py });
         });
     };
-    const open = () => {
-        if (!_root.current)
+    //BEGIN system modifications
+    const open = async() => {
+        UpdUtils.LogSys(LIBN, 0, 'Lightbox image open() called for: '+children.props.source.uri);
+
+        // Checking if picture is a wrapped private picture or not
+        let isWrappedPrivatePicture = false;
+        let PPplatformNickname = false;
+        let contentsInsideEnvelope = false;
+        let fileContentsOriginal;
+        try {
+ 
+            UpdUtils.LogSys(LIBN, 0, 'Reading file');
+            fileContentsOriginal = await FileSystem.readAsStringAsync(children.props.source.uri, {encoding: 'base64'});
+            UpdUtils.LogSys(LIBN, 0, 'File loaded');
+            UpdUtils.LogSys(LIBN, 0, 'Checking file type');
+            let s = UpdUtils.EncodeFromB64ToBinary(fileContentsOriginal);
+
+            UpdUtils.LogSys(LIBN, 1, 'Parsing PNG metadata');
+            let list = png.splitChunk(s);
+            UpdUtils.LogSys(LIBN, 2, 'Metadata contents:'+JSON.stringify(list));
+
+            list.forEach(function (arrayItem) {
+                if (arrayItem?.type === 'ppPp' && arrayItem?.data) {
+                    UpdUtils.LogSys(LIBN, 1, 'Found ppPp chunk');
+                    contentsInsideEnvelope = JSON.parse(arrayItem.data);  // This holds the payload
+                }
+                if (arrayItem?.type === 'ppPq' && arrayItem?.data) {
+                    UpdUtils.LogSys(LIBN, 1, 'Found ppPq chunk');
+                    isWrappedPrivatePicture = true;
+                    PPplatformNickname = arrayItem.data;  // This holds the PP platform nickname
+                }
+            });
+
+        } catch(exc) {
+            UpdUtils.LogSys(LIBN, 1, 'Catched exception while checking if picture is a wrapped private picture or not: ' + exc.message);
+        }
+
+        UpdUtils.LogSys(LIBN, 0, 'Check done');
+        if (isWrappedPrivatePicture) {  // check if the file is a wrapped private picture, and if so unwrap it calling its deep link
+            UpdUtils.LogSys(LIBN, 0, 'We have a wrapped private picture *.*.*.*.');
+            try {
+                await tryAcquire(mutexPrivatePictureDisplay).runExclusive(async() => {  // tryAcquire => non-blocking; if mutex is busy it throws error
+            
+                    if (PPplatformNickname===false) {
+                        throw Error('Found a ppPq chunk without a ppPp chunk.');
+                    }
+
+                    if ( ! PARAM_PP__PLATFORM_NICKNAME_UNWRAPPING_LIST.includes(PPplatformNickname)) {
+                        throw Error('The ppPq chunk indicates a PP platform nickname that is not in our allowed list.');
+                    }
+
+                    UpdUtils.LogSys(LIBN, 1, 'mutexPrivatePictureDisplay acquired to begin operations');
+
+                    const documentDirectory = normalizeEndingSlash(FileSystem.documentDirectory);
+
+                    // Prepare and launch deep link
+            
+                    // NOTE: Deep link params are only available in the EAS build
+                    let URLofPPselectionService = new URL(
+                        PARAM_PP__SERVICE_WRAPUNWRAP_BASE_URL_PART1+
+                        PPplatformNickname+
+                        PARAM_PP__SERVICE_WRAPUNWRAP_BASE_URL_PART2
+                    );
+                    URLofPPselectionService.searchParams.append('callbackURL', PARAM_PP__APP_URL_SCHEME+'://'+PARAM_PP__APP_URL_MESSAGING_DISPLAY_HOSTNAME+'/');
+                    PPreplyAuthenticationString = UpdUtils.GenerateRandomString(PARAM_PP__LENGTH_AUTH);
+                    URLofPPselectionService.searchParams.append('authToken', PPreplyAuthenticationString);
+                    URLofPPselectionService.searchParams.append('operationName', 'unwrap');
+                    URLofPPselectionService.searchParams.append('imageUriReference', children.props.source.uri);
+                    
+                    // We assume that the extension coincides with the ISO content-type            
+                    let fileExt = children.props.source.uri.split('.').pop();
+                    if (!UpdUtils.IsValidImageExtensionAndContentType(fileExt)) {
+                        throw Error('Image URI extension is not valid.');                   
+                    }       
+
+                    //await Linking.openURL(URLofPPselectionService.toString());  // Need to await Linking.openURL() to properly catch errors
+                    if (Platform.OS === 'android') {
+            
+                        // ANDROID ---------------------------------------------------------------------------
+
+                        UpdUtils.LogSys(LIBN, 1, 'Creating dir '+PARAM_PP__APP_TMP_FOLDER_NAME+' if not exists');
+                        // Create dir for exchanging files with PP client, if it does not exist
+                        try {
+                            await FileSystem.makeDirectoryAsync(documentDirectory + PARAM_PP__APP_TMP_FOLDER_NAME);
+                        }
+                        // Ignored -- Directory already exists
+                        // We can't distinguish between 'directory already exists' and other types of errors
+                        catch(err) { 
+                          // Do nothing
+                          UpdUtils.LogSys(LIBN, 1, 'Ignoring error');
+                          UpdUtils.LogSys(LIBN, 2, err?.stack);
+                        }
+              
+                        UpdUtils.LogSys(LIBN, 2, 'fileContentsOriginal: '+fileContentsOriginal);
+                        UpdUtils.LogSys(LIBN, 1, 'fileContentsOriginal length: '+fileContentsOriginal.length);
+                        UpdUtils.LogSys(LIBN, 1, 'Preparing temporary image file; this is the file with wrapped contents');
+                        // Prepare temporary image file with wrapped contents
+                        //UTF8 encoded strings cannot represent arbitrary binary values
+                        //https://docs.snowflake.com/en/sql-reference/binary-input-output
+                        PPandroidTmpFilePath = documentDirectory + PARAM_PP__APP_TMP_FOLDER_NAME + '/' + uuidv4() + '.tmp.' + fileExt;
+                        UpdUtils.LogSys(LIBN, 1, 'PPandroidTmpFilePath='+PPandroidTmpFilePath);
+                        /**
+                         * We need to copy the wrapped image file onto a temporary file in a specific directory. 
+                         * This is because we have set permissions over what directories can contain files that 
+                         * are shared via the FileProvider API (otherwise, a 'Failed to find configured root that 
+                         * contains' error is raised). In our case, only the PARAM_PP__APP_TMP_FOLDER_NAME is set 
+                         * to have this permission, as set in the android-manifest-fileprovider-definitions.js 
+                         * plugin. In this messagning app, image files are located in the chatHistoryPictures 
+                         * folder. Once the ppclient has finished displaying the private picture, the Finally 
+                         * clause below will be in charge of deleting the temporary file.
+                         */
+                        await FileSystem.writeAsStringAsync(PPandroidTmpFilePath, fileContentsOriginal, {encoding: 'base64'});
+                        UpdUtils.LogSys(LIBN, 1, 'Full path is: '+PPandroidTmpFilePath);
+
+                        PPandroidContentUri = await FileProvider.getUriForFile(PARAM_PP__APP_ANDROID_FILEPROVIDER_AUTHORITY, PPandroidTmpFilePath);
+                        UpdUtils.LogSys(LIBN, 1, 'FileProvider contentUri: ' + PPandroidContentUri);
+                        await FileProvider.grantUriPermissionR(PARAM_PP__PPCLIENT_ANDROID_NAME, PPandroidContentUri);
+                        UpdUtils.LogSys(LIBN, 1, 'FileProvider R permission granted');
+                        URLofPPselectionService.searchParams.append('fileUri', PPandroidContentUri);
+                
+                    } else if (Platform.OS === 'ios') {
+            
+                        // iOS ---------------------------------------------------------------------------
+            
+                        URLofPPselectionService.searchParams.append('fileContents', UpdUtils.SafeUrlEncodeForB64(fileContentsOriginal));
+            
+                    } else {
+            
+                        throw new Error('Unsupported platform: '+Platform.OS);
+            
+                    }
+                    
+                    //// In Android, the AppLink.maybeOpenURL() command below is equivalent to:
+                    //let wasOpened = await SendIntentAndroid.openAppWithData(
+                    //'pt.lasige.safex.ppclient',
+                    //URLofPPselectionService.toString(),
+                    ////PPandroidContentUri,
+                    //null,
+                    //null
+                    //);
+                        
+                    UpdUtils.LogSys(LIBN, 0, 'About to call URL to open');
+
+                    await AppLink.maybeOpenURL(
+                        URLofPPselectionService.toString(), 
+                        { 
+                            appName : PARAM_PP__SERVICE_APPNAME,
+                            appStoreId : PARAM_PP__SERVICE_IOSAPPID,
+                            appStoreLocale : PARAM_PP__SERVICE_IOSAPPSTORELOCALE,
+                            playStoreId : PARAM_PP__SERVICE_PLAYSTOREID,
+                        },
+                        async function(){ await UpdUtils.AsyncAlert('You will be prompted to install the PP client app. Once installed, come back here and tap on the picture again.'); }
+                    );  // We need to pass a callback function to show the Alert, because Alerts are not shown when the app is in the background.
+                        // See: https://stackoverflow.com/questions/74662876/popup-alert-dialog-in-react-native-android-app-while-app-is-not-in-foreground
+                        
+                    UpdUtils.LogSys(LIBN, 0, 'URL call to open has completed');
+                    UpdUtils.LogSys(LIBN, 2, 'URL is: ' + URLofPPselectionService.toString());
+            
+                    
+                    // (*) Blocks execution; awaits processing of PP app
+                    await mutexPrivatePictureDisplay.acquire();
+                    UpdUtils.LogSys(LIBN, 0, 'Execution resumed');
+            
+            
+                    if (PPselectorResult != null) {
+                        throw PPselectorResult;
+                    } else {
+                        // No error - continue
+                    }
+            
+                });
+            } catch (e) {
+                if (e === E_ALREADY_LOCKED) {
+                    UpdUtils.LogSys(LIBN, 1, 'There is another operation in progress'); 
+                    // Instead of throwing an error, we show a warning message. We deem a 'picture visualisation operation' to be safely idempotent
+                    await UpdUtils.AsyncAlert('There is another private picture viualisation in progress. Tap the back button on the PP client app or wait for the timeout, and try again.');
+                } else if (e === E_TIMEOUT) {
+                    UpdUtils.LogSys(LIBN, 1, 'mutexPrivatePictureDisplay released by timeout'); 
+                    throw new Error('There has been a timeout. Make sure that the PP client app is installed. Keep the PP client app in the foreground while it is processing information.');
+                } else {
+                    UpdUtils.LogSys(LIBN, 1, 'An error has occurred: '+e.stack); 
+                    throw e;
+                }
+            } finally {
+                UpdUtils.LogSys(LIBN, 0, 'Finally clause');
+                // NOTE: if we do
+                //  const mutexRelease = await mutexPrivatePictureAccess.acquire();
+                // then,
+                //  mutexRelease() is equivalent to mutexPrivatePictureAccess.release().
+                //
+                // NOTE: mutexRelease() is idempotent.
+                //
+            
+                //mutexPrivatePictureAccess.release();  // NOT necessary to release here!!
+            
+                try {
+                    if (Platform.OS === 'android') {
+                        if (PPandroidContentUri != '') {
+                            await FileProvider.revokeUriPermissionR(PPandroidContentUri); 
+                            UpdUtils.LogSys(LIBN, 1, 'PPandroidContentUri permissions revoked on '+PPandroidContentUri); 
+                        } else {
+                            UpdUtils.LogSys(LIBN, 1, 'PPandroidContentUri permissions NOT revoked on PPandroidContentUri because it is empty');  // In case there was previously an exception
+                        }
+                        if (PPandroidTmpFilePath != '') {
+                            await FileSystem.deleteAsync(PPandroidTmpFilePath, {idempotent: true});  // With {idempotent: true}, it does not throw error if the file does not exist.
+                            UpdUtils.LogSys(LIBN, 1, 'Temporary file deleted: '+PPandroidTmpFilePath); 
+                        } else {
+                            UpdUtils.LogSys(LIBN, 1, 'Temporary file of PPandroidTmpFilePath NOT deleted because path is empty'); 
+                        }
+                    } else {
+                        // iOS: No cleanup
+                    }
+                } catch (err) {
+                    UpdUtils.LogSys(LIBN, 1, 'Error when cleaning up after picture display: '+err.stack); 
+                } finally {
+                    UpdUtils.LogSys(LIBN, 0, 'End of: Finally clause');
+                    UpdUtils.LogSys(LIBN, 0, 'Returning from Lightbox.js hook on a private picture'); 
+                    return;
+                }
+        
+            }
+        } else {  // It is not a private picture
+            // continue
+            UpdUtils.LogSys(LIBN, 0, 'Resuming from Lightbox.js hook on a picture that is not a wrapped private picture *.*.*.*.'); 
+        }
+    
+        //END system modifications
+    if (!_root.current)
             return;
         onOpen();
         wrapMeasureWithCallback((newOrigin) => {
